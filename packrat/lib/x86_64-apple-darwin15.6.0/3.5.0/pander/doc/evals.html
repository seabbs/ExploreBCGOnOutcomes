<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Graphs and Graphical Options</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p><code>evals</code> is aimed at collecting as much information as possible while evaluating R code. It can evaluate a character vector of R expressions, and it returns a list of information captured while running them:</p>

<ul>
<li><code>src</code> holds the R expression,</li>
<li><code>result</code> contains the raw R object as-is,</li>
<li><code>output</code> represents how the R object is printed to the standard output,</li>
<li><code>type</code> is the class of the returned R object,</li>
<li><code>msg</code> is a list of messages captured while evaluating the R expression. Among other messages, warnings/errors will appear here.</li>
<li><code>stdout</code> contains what, if anything, was written to the standard output.</li>
</ul>

<p>Besides capturing evaluation information, <code>evals</code> is able to automatically identify whether an R expression is returning anything to a graphical device, and can save the resulting image in a variety of file formats.</p>

<p>Another interesting <code>evals</code> feature is caching the results of evaluated expressions. Read the <a href="#result-caching">caching</a> section for more details.</p>

<p><code>evals</code> has a large number of options, which allow users to customize the call exactly as needed. Here we will focus on the most useful features, but the full list of options, with explanations, can be viewed by calling <code>?evalsOptions</code>. Also <code>evals</code> support permanent options that will persist for all calls to <code>evals</code>, this can be achieved by calling <code>evalsOptions</code>.</p>

<p>Let&#39;s start with a basic example by evaluating <code>1:10</code> and collecting all information about it:</p>

<pre><code class="r">evals(&#39;1:10&#39;)
#&gt; [[1]]
#&gt; $src
#&gt; [1] &quot;1:10&quot;
#&gt; 
#&gt; $result
#&gt;  [1]  1  2  3  4  5  6  7  8  9 10
#&gt; 
#&gt; $output
#&gt; [1] &quot; [1]  1  2  3  4  5  6  7  8  9 10&quot;
#&gt; 
#&gt; $type
#&gt; [1] &quot;integer&quot;
#&gt; 
#&gt; $msg
#&gt; $msg$messages
#&gt; NULL
#&gt; 
#&gt; $msg$warnings
#&gt; NULL
#&gt; 
#&gt; $msg$errors
#&gt; NULL
#&gt; 
#&gt; 
#&gt; $stdout
#&gt; NULL
#&gt; 
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;evals&quot;
</code></pre>

<p>Not all the information might be useful, so <code>evals</code> makes it is possible to capture only some of the information, by specifying the <code>output</code> parameter:</p>

<pre><code class="r">evals(&#39;1:10&#39;, output = c(&#39;result&#39;, &#39;output&#39;))
#&gt; [[1]]
#&gt; $result
#&gt;  [1]  1  2  3  4  5  6  7  8  9 10
#&gt; 
#&gt; $output
#&gt; [1] &quot; [1]  1  2  3  4  5  6  7  8  9 10&quot;
#&gt; 
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;evals&quot;
</code></pre>

<p>One of the neat features of <code>evals</code> that it catches errors/warnings without interrupting the evaluation and saves them.</p>

<pre><code class="r">evals(&#39;x&#39;)[[1]]$msg
#&gt; $messages
#&gt; NULL
#&gt; 
#&gt; $warnings
#&gt; NULL
#&gt; 
#&gt; $errors
#&gt; [1] &quot;object &#39;x&#39; not found&quot;
evals(&#39;as.numeric(&quot;1.1a&quot;)&#39;)[[1]]$msg
#&gt; $messages
#&gt; NULL
#&gt; 
#&gt; $warnings
#&gt; [1] &quot;NAs introduced by coercion&quot;
#&gt; 
#&gt; $errors
#&gt; NULL
</code></pre>

<h2>Graphs and Graphical Options</h2>

<p>As mentioned before, <code>evals</code> captures the output to graphical devices and saves it:</p>

<pre><code class="r">evals(&#39;plot(mtcars)&#39;)[[1]]$result
#&gt; [1] &quot;my_plots/test.jpeg&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;image&quot;
</code></pre>

<p><img src="http://rapporter.github.io/pander/plots/evals-mtcars.jpeg" alt=""/></p>

<p>You can specify the output directory using the <code>graph.dir</code> parameter, and the output type using the <code>graph.output</code> parameter. Currently, it could be any of <code>grDevices</code>: <code>png</code>, <code>bmp</code>,<code>jpeg</code>,<code>jpg</code>, <code>tiff</code>, <code>svg</code>,  or <code>pdf</code>.</p>

<pre><code class="r">evals(&#39;plot(mtcars)&#39;, graph.dir = &#39;my_plots&#39;, graph.output = &#39;jpg&#39;)[[1]]$result
#&gt; [1] &quot;my_plots/test.jpeg&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;image&quot;
</code></pre>

<p>Moreover, <code>evals</code> provides facilities to:</p>

<ul>
<li>save the environments in which plots were generated</li>
<li>save the plot via <code>recordPlot</code> to distinct files with <code>recodplot</code> extension</li>
<li>save the raw R object returned (usually with <code>lattice</code> or <code>ggplot2</code>) while generating the plot to distinct files with <code>RDS</code> extension</li>
</ul>

<h3>Style unification</h3>

<p><code>evals</code> provides very powerful facilities to unify the styling of images produced by different packages, like <code>ggplot2</code> and <code>lattice</code>.</p>

<p>Let&#39;s prepare the data for plotting:</p>

<pre><code class="r">## generating dataset
set.seed(1)
df &lt;- mtcars[, c(&#39;hp&#39;, &#39;wt&#39;)]
df$factor &lt;- sample(c(&#39;Foo&#39;, &#39;Bar&#39;, &#39;Foo bar&#39;), size = nrow(df), replace = TRUE)
df$factor2 &lt;- sample(c(&#39;Foo&#39;, &#39;Bar&#39;, &#39;Foo bar&#39;), size = nrow(df), replace = TRUE)
df$time &lt;- 1:nrow(df)
</code></pre>

<p>Now let&#39;s plot the histograms:</p>

<pre><code class="r">evalsOptions(&#39;graph.unify&#39;, TRUE)
evals(&#39;histogram(df$hp, main = &quot;Histogram with lattice&quot;)&#39;)[[1]]$result
#&gt; [1] &quot;my_plots/test.jpeg&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;image&quot;
evals(&#39;ggplot(df) + geom_histogram(aes(x = hp), binwidth = 50) + ggtitle(&quot;Histogram with ggplot2&quot;)&#39;)[[1]]$result
#&gt; [1] &quot;my_plots/test.jpeg&quot;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;image&quot;
evalsOptions(&#39;graph.unify&#39;, FALSE)
</code></pre>

<p><img src="http://rapporter.github.io/pander/plots/evals-lattice.jpeg" alt=""/>
<img src="http://rapporter.github.io/pander/plots/evals-ggplot2.jpeg" alt=""/></p>

<p>Options for unification can be set with <code>panderOptions</code>. For example:</p>

<pre><code class="r">panderOptions(&#39;graph.fontfamily&#39;, &quot;Comic Sans MS&quot;)
panderOptions(&#39;graph.fontsize&#39;, 18)
panderOptions(&#39;graph.fontcolor&#39;, &#39;blue&#39;)
panderOptions(&#39;graph.grid.color&#39;, &#39;blue&#39;)
panderOptions(&#39;graph.axis.angle&#39;, 3)
panderOptions(&#39;graph.boxes&#39;, T)
panderOptions(&#39;graph.legend.position&#39;, &#39;top&#39;)
panderOptions(&#39;graph.colors&#39;, rainbow(5))
panderOptions(&#39;graph.grid&#39;, FALSE)
panderOptions(&#39;graph.symbol&#39;, 22)
</code></pre>

<p>More information and examples on style unification can be obtained by <code>Pandoc.brew</code>ing the tutorial available <a href="https://github.com/Rapporter/pander/blob/master/inst/examples/graphs.brew">here</a>.</p>

<h2>Logging</h2>

<p>To make execution and debugging easier to understand, <code>evals</code> provides logging with the <code>log</code> parameter. Logging in <code>evals</code> relies on the <a href="cran.r-project.org/web/packages/futile.logger/futile.logger.pdf"><code>futile.logger</code></a> package,  which provides a logging API similar to <code>log4j</code>. Basic example:</p>

<pre><code class="r">x &lt;- evals(&#39;1:10&#39;, log = &#39;foo&#39;)
#&gt; INFO [2017-08-06 14:33:28] Command run: 1:10
</code></pre>

<p><code>futile.logger</code>&#39;s thresholds range from most verbose to least verbose: <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>FATAL</code>. The threshold defaults to <code>INFO</code>, which will hide some unessential information. To permanently set the threshold for logger use <code>flog.threshold</code>:</p>

<pre><code class="r">evalsOptions(&#39;log&#39;, &#39;evals&#39;)
flog.threshold(TRACE, &#39;evals&#39;)
#&gt; NULL
x &lt;- evals(&#39;1:10&#39;, cache.time = 0)
#&gt; INFO [2017-08-06 14:33:28] Command run: 1:10
#&gt; TRACE [2017-08-06 14:33:28] Cached result
#&gt; DEBUG [2017-08-06 14:33:28] Returned object: class = integer, length = 10, dim = , size = 88 bytes
</code></pre>

<p><code>futile.logger</code> also provides a very useful ability to write logs to files instead of printing them to the prompt:</p>

<pre><code class="r">t &lt;- tempfile()
flog.appender(appender.file(t), name = &#39;evals&#39;)
#&gt; NULL
x &lt;- evals(&#39;1:10&#39;, log = &#39;evals&#39;)
readLines(t)
#&gt; [1] &quot;INFO [2017-08-06 14:33:28] Command run: 1:10&quot;          
#&gt; [2] &quot;TRACE [2017-08-06 14:33:28] Returning cached R object.&quot;
# revert back to console
flog.appender(appender.console(), name = &#39;evals&#39;)
#&gt; NULL
</code></pre>

<h2>Result Caching</h2>

<p><code>evals</code> is uses a custom caching algorithm to cache the results of evaluated R expressions.</p>

<h3>How it works</h3>

<ul>
<li>All R code passed to <code>evals</code> is split into single expressions and parsed.</li>
<li>For each R expression (function call, assignment, etc.), <code>evals</code> extracts symbols in a separate list in <code>getCallParts</code>. This list describes the unique structure and the content of the passed R expressions</li>
<li>A hash is computed for each list element and cached in <code>pander</code>&#39;s local environments. This is useful if you are using large data frames; otherwise, the caching algorithm would have to compute the hash for the same data frame each time it&#39;s touched! This way the hash is recomputed only if the R object with the given name is changed.</li>
<li>The list of such R objects is serialized, then an SHA-1 hash is computed, taking into consideration <code>panderOptions</code> and <code>evalsOptions</code>, which all together is unique and there is no real risk of collision.</li>
<li>If <code>evals</code> can find the cached results in the appropriate environment (if <code>cache.mode set</code> to environment) or in a file named to the computed hash (if <code>cache.mode</code> set to <code>disk</code>), then it is returned on the spot. The objects modified/created by the cached code are also updated.</li>
<li>Otherwise the call is evaluated and the results and the modified R objects of the environment are optionally saved to cache (e.g. if <code>cache</code> is active and if the evaluation <code>proc.time()</code> &gt; <code>cache.time</code> parameter). Cached results are saved in <code>cached.results</code> in <code>pander</code>&#39;s namespace. <code>evals</code> also remembers if R expressions change the evaluation environment (for example assignments) and saves such changes in <code>cached.environemnts</code> in <code>pander</code>&#39;s namespace.</li>
</ul>

<h3>Examples</h3>

<p>We will set <code>cache.time</code> to 0, to cache all expressions regardless of time they took to evaluate. We will also use the logging facilites described above to simplify the understanding of how caching works.</p>

<pre><code class="r">evalsOptions(&#39;cache.time&#39;, 0)
evalsOptions(&#39;log&#39;, &#39;evals&#39;)
flog.threshold(TRACE, &#39;evals&#39;)
#&gt; NULL
</code></pre>

<p>Let&#39;s start with small example.</p>

<pre><code class="r">system.time(evals(&#39;1:1e5&#39;))
#&gt; INFO [2017-08-06 14:33:28] Command run: 1:1e+05
#&gt; TRACE [2017-08-06 14:33:29] Cached result
#&gt; DEBUG [2017-08-06 14:33:29] Returned object: class = integer, length = 100000, dim = , size = 400040 bytes
#&gt;    user  system elapsed 
#&gt;   0.532   0.004   0.538
system.time(evals(&#39;1:1e5&#39;))
#&gt; INFO [2017-08-06 14:33:29] Command run: 1:1e+05
#&gt; TRACE [2017-08-06 14:33:29] Returning cached R object.
#&gt;    user  system elapsed 
#&gt;   0.004   0.000   0.003
</code></pre>

<p>Results cached by <code>evals</code> can be stored in an <em>environment</em> in current <code>R</code> session or permanently on disk by setting the <code>cache.mode</code> parameter appropriately.</p>

<pre><code class="r">res &lt;- evals(&#39;1:1e5&#39;, cache.mode = &#39;disk&#39;, cache.dir = &#39;cachedir&#39;)
#&gt; INFO [2017-08-06 14:33:29] Command run: 1:1e+05
#&gt; TRACE [2017-08-06 14:33:30] Cached result
#&gt; DEBUG [2017-08-06 14:33:30] Returned object: class = integer, length = 100000, dim = , size = 400040 bytes
list.files(&#39;cachedir&#39;)
#&gt; [1] &quot;b10e5bbf7cfb1e356b05d59fc52ea05f49835fcc&quot;
</code></pre>

<p>Since the hash for caching is computed based on the <em>structure</em> and <em>content</em> of the R commands, instead of the  variable names or R expressions, <code>evals</code> is able to achieve great results:</p>

<pre><code class="r">x &lt;- mtcars$hp
y &lt;- 1e3
system.time(evals(&#39;sapply(rep(x, y), mean)&#39;))
#&gt; INFO [2017-08-06 14:33:30] Command run: sapply(rep(x, y), mean)
#&gt; TRACE [2017-08-06 14:33:30] Cached result
#&gt; DEBUG [2017-08-06 14:33:30] Returned object: class = numeric, length = 32000, dim = , size = 256040 bytes
#&gt;    user  system elapsed 
#&gt;   0.168   0.000   0.170
</code></pre>

<p>Let us create some custom functions and variables, which are not identical to the above call:</p>

<pre><code class="r">f &lt;- sapply
g &lt;- rep
h &lt;- mean
X &lt;- mtcars$hp * 1
Y &lt;- 1000
system.time(evals(&#39;f(g(X, Y), h)&#39;))
#&gt; INFO [2017-08-06 14:33:30] Command run: f(g(X, Y), h)
#&gt; TRACE [2017-08-06 14:33:30] Returning cached R object.
#&gt;    user  system elapsed 
#&gt;   0.004   0.000   0.005
</code></pre>

<p>Another important feature of <code>evals</code> is that it notes changes in the evaluation environment. For example:</p>

<pre><code class="r">x &lt;- 1
res &lt;- evals(&#39;x &lt;- 1:10;&#39;)
#&gt; INFO [2017-08-06 14:33:30] Command run: x &lt;- 1:10
#&gt; TRACE [2017-08-06 14:33:30] Cached result
</code></pre>

<p><code>x &lt;- 1:10</code> will be cached; if the same assignment occurs again we won&#39;t need to evaluate it. But what about the change of <code>x</code> when we get the result from the cache? <code>evals</code> takes care of that.</p>

<p>So in the following example we can see that <code>x &lt;- 1:10</code> is not evaluated, but retrieved from cache with the change to <code>x</code> in the environment.</p>

<pre><code class="r">evals(&#39;x &lt;- 1:10; x[3]&#39;)[[2]]$result
#&gt; INFO [2017-08-06 14:33:30] Command run: x &lt;- 1:10
#&gt; TRACE [2017-08-06 14:33:30] Returning cached R object.
#&gt; INFO [2017-08-06 14:33:30] Command run: x[3]
#&gt; TRACE [2017-08-06 14:33:30] Cached result
#&gt; DEBUG [2017-08-06 14:33:30] Returned object: class = integer, length = 1, dim = , size = 48 bytes
#&gt; [1] 3
</code></pre>

<p>Also <code>evals</code> is able to cache output to graphical devices produced during evaluation:</p>

<pre><code class="r">system.time(evals(&#39;plot(mtcars)&#39;))
#&gt; INFO [2017-08-06 14:33:30] Command run: plot(mtcars)
#&gt; TRACE [2017-08-06 14:33:30] Image file written: my_plots/test.jpeg
#&gt; TRACE [2017-08-06 14:33:30] Cached result
#&gt;    user  system elapsed 
#&gt;   0.116   0.000   0.115
system.time(evals(&#39;plot(mtcars)&#39;))
#&gt; INFO [2017-08-06 14:33:30] Command run: plot(mtcars)
#&gt; TRACE [2017-08-06 14:33:30] Image found in cache: my_plots/test.jpeg
#&gt;    user  system elapsed 
#&gt;   0.004   0.000   0.004
</code></pre>

</body>

</html>
